import os
import numpy as np
from datetime import datetime as dt
from typing import List, Callable
import collections
import random
import re

# debugger from class 

SHOW_ARGS = True  

def debugger(fun: Callable) -> Callable:
    def _wrapper(*args, **kwargs):
        print(f'{fun.__name__} called')
        if SHOW_ARGS:
            print(f'args: {args}')
            print(f'kwargs: {kwargs}')

        t0 = dt.now()
        # always write this line like this 

        results = fun(*args, **kwargs)
        print(f'ran for {dt.now()-t0} sec(s)')

        # do not modify the return signature 
        return results
    return _wrapper

# conversions 
# sweazey_helpers.py (Corrected Snippet)
def decks_loaded(data_folder='./data/sweazey_decks/'): # <-- CORRECTED PATH
    """
    Calculates the total number of decks generated by summing up the counts
    from the filenames in the data directory.
    """
    # Regex to capture the deck count from 'decks_10000_seed21.npy'
    filename_pattern = re.compile(r'^decks_(\d+)_seed\d+\.npy$')
    total_decks = 0
    if not os.path.isdir(data_folder):
        print(f"Warning: Data directory '{data_folder}' not found. Returning 0 decks.")
        return 0
    for filename in os.listdir(data_folder):
        match = filename_pattern.match(filename)
        if match:
            deck_count_in_file = int(match.group(1))
            total_decks += deck_count_in_file
    return total_decks

def string_to_binary(seq: str) -> List[int]:
    '''
    convert a string like 'RRR' to binary [1, 1, 1]
    '''
    return [1 if char == 'R' else 0 for char in seq]

def binary_to_string(seq: List[int]) -> str:
    '''
    convert binary like [1, 0, 1] to string 'RBR'
    '''
    return ''.join('R' if bit == 1 else 'B' for bit in seq)

# play the game 

# NEEDS EDITING FOR DB
def match_pattern(deck: List[int], pattern: List[int]) -> int:
    '''
    return index of first time pattern is found in deck
    if pattern is not found in deck, return -1
    '''
    m, n = len(pattern), len(deck)
    for i in range(n - m + 1):
        if deck[i:i+m] == pattern:
            return i
        
    # if pattern not found 
    return -1

# NEEDS EDITING FOR DB
def play_game(deck: List[int], p1: List[int], p2: List[int]) -> int:
    '''
    simulate single round (trick) of penney's game 
    return 1 if p1 wins, 2 if p2 wins, 0 if draw 
    '''

    idx1 = match_pattern(deck, p1)
    idx2 = match_pattern(deck, p2)

    if idx1 == -1 and idx2 == -1: # neither pattern found, draw
        return 0 
    
    if idx1 == -1 and idx2 != -1: # only pattern 2 found, player 2 wins
        return 2
    
    if idx1 != -1 and idx2 == -1: # only pattern 1 found, player 1 wins
        return 1
    
    if idx1 < idx2: # pattern 1 appears first, player 1 wins 
        return 1 
    
    elif idx2 < idx1: # pattern 2 appears first, player 2 wins
        return 2

    else: 
        return 0 # draw (not technically possible if following rules)